<h1>Operating System Report</h1>

<h2>1. Page Replacement Algorithm</h2>
<p>In an operating system that uses paging for virtual memory management, the system decides which page should be removed from the main memory and written to disk to free up space for a new page. This project uses the First-Come-First-Served (FCFS) page replacement algorithm.</p>

<h2>2. FCFS Algorithm</h2>
<p>This algorithm associates each page with the time it entered memory. With FCFS, the process that requested the CPU first is assigned the CPU first. When we need to replace a page, we select the oldest page. We use a FIFO (First-In-First-Out) queue to manage the pages in memory and execute this algorithm. In the replacement process, the page at the front of the queue is selected, and the new page is added to the end of the queue. Hence, some resources refer to this algorithm as FIFO. When the CPU is free, it is allocated to the process at the front of the queue, and then the running process is removed from the queue. The advantages of this algorithm include its simplicity in implementation and understanding, and it imposes minimal overhead on the operating system. Additionally, this algorithm does not require prior knowledge about the processes. However, it does not always provide good performance. For example, the replaced page might be an old module that is no longer useful, or it might be a frequently used variable that was started earlier and is in constant use. If an active page is selected for replacement, everything will work correctly. After removing the active page and inserting a new page, a page fault occurs almost immediately as the active page is retrieved. Therefore, a bad replacement choice increases the page fault rate and slows down process execution. However, it does not lead to incorrect execution. This algorithm has the Belady anomaly and is rarely used.</p>

<h2>3. MATLAB Simulation</h2>
<p>In this section, we want to simulate the project using MATLAB. We define a function named <code>FIFO</code> with variables <code>q</code> (which is our queue) and <code>sizeS</code> (which is our frame size). <code>N</code> specifies the size of our queue. The <code>table</code> matrix has <code>sizeS + 1</code> rows because the first row is used for better display (<code>table(1,:)</code> = <code>q</code>) and <code>N</code> columns. <code>Pages</code> is the number of active pages. If <code>N = 0</code>, there will be no page fault, and <code>fault = 0</code> will be shown. If <code>N</code> is less than the number of frames, it finds the location of the page on disk and places the pages one by one into the frame. In the other case, it operates according to the algorithm defined in section 2. That is, if the frame capacity is full, it removes the oldest page (i.e., the page that was first in memory) and replaces it with the current page, adding the current page to the queue, which increases the page fault count.</p>

<h2>4. Lucky Number Generator</h2>
<p>We have defined a function called <code>LuckyNum_generator</code> that generates random numbers. <code>N</code> specifies the length of our queue. In the <code>LuckyNum_generator</code> function, we first obtain a number using the system clock (<code>tic</code>), then divide it by <code>M</code> (a large number), and consider the remainder as the generated random number. We then use chi-squared tests to determine its similarity to both the Uniform and Normal distributions. The outputs are visible in the MATLAB command box. If <code>h</code> is zero, it means we cannot reject the null hypothesis that these numbers come from the mentioned distribution. If <code>h</code> is one, we can reject the null hypothesis with a confidence level of 1-alpha. The <code>p</code> value in these outputs indicates the p-value. At the end of the function, a histogram of the generated numbers is shown.</p>

<h2>5. Main File</h2>
<p>In the main file, named <code>main</code>, we have several sections. The first section, considered as the general section three, allows manual selection of the queue. In section 4, values can be placed directly in the code. In the "all in one" section, the user can provide input. The user is asked for four inputs: the number of frames, the size of our queue, the <code>M</code> variable described in section 4, and <code>alpha</code>, our confidence level. The outputs include <code>h</code> and <code>p</code>, which are explained in section 4, as well as the chi-squared test results <code>O</code> and <code>E</code>. The number of page faults and hits is also shown. The histogram in the "all in one" section displays the generated numbers. The table shows the algorithm's process, with a portion of it displayed here.</p>

<h2>6. Random String Generation</h2>
<p>At the end of the code, we generate a random string 100 times. In each iteration, we run the FIFO algorithm, then determine the number of faults based on the number of hits, and finally calculate and display the average and variance of the faults. A general example of the output is shown below.</p>

<h2>7. Analyzing Page Faults</h2>
<p>In this section, we examine page faults according to the number of free frames. Contrary to expectations, providing more space to a process may not always improve its performance. We observe that increasing allocated frames can lead to an increase in page faults. This result is known as the Belady anomaly, which was initially discussed. The image below shows a sample where, from frame 13 to 14, an anomaly occurred, and contrary to expectations, the page faults increased.</p>
